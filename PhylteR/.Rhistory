write.tree(L,file = "TESTRAPPORT20x20-1S-1G-1C")
RES
di2multi
?di2multi
di2multi
source('~/Documents/Phylter/PhylteR.R')
di2multi
?di2multi
tree = read.tree("treetest.tree")
tree = read.tree("/home/aurore/treetest.tree")
tree
plot(tree)
tree2 = di2multi(tree)
tree$edge.length
tree2$edge.length
tree2 = di2multi(tree, tol=1e-3)
tree2$edge.length
tree2 = di2multi(tree, tol=1e-2)
tree2$edge.length
plot(tree)
plot(tree2)
?mutli2di
?multi2di
?multi2di()
tree3 = multi2di(tree2)
tree3$edge.length
plot(tree3)
k=1.5
thres = 0.5
outl.sub <- function(x, k) {
return(x > quantile(x)[4] + k * IQR(x) + 1e-10)
##note: the 1e-10 ,is because when all values are similar except one, the first one is considered as equal to the third quartile... May be a bug in quantile function?
}
tabgn <- normalize(mat2WR, "genes")
tabgn.TF <- t(apply(tabgn, 1, outl.sub, k = k))
tabsp <- normalize(mat2WR, "species")
tabsp.TF <- apply(tabsp,2, outl.sub, k = k)
tabgn.TF[tabgn.TF == FALSE] <- 0
tabgn.TF[tabgn.TF == TRUE] <- 1
tabsp.TF[tabsp.TF == FALSE] <- 0
tabsp.TF[tabsp.TF == TRUE] <- 1
score.genes <- apply(tabgn.TF, 2, function(x) {sum(x) / length(x)})
score.species <- apply(tabsp.TF, 1, function(x) {sum(x) / length(x)})
out.genes <- names(score.genes)[score.genes > thres]
out.species <- names(score.species)[score.species > thres]
RES <- NULL
#RES$mat2WR <- mat2WR
#RES$thres <- thres
#RES$allgn <- names(score.genes)
#RES$allsp <- names(score.species)
#RES$scoregn <- score.genes
#RES$scoresp <- score.species
#RES$TFgn <- score.genes>thres
#RES$TFsp <- score.species>thres
RES$outgn <- out.genes
RES$outsp <- out.species
tree2
WR
trees=read.tree("/home/aurore/Documents/Phylter/trees/rose/TESTRAPPORT20x20-1S-1G-1C")
trees
PhylteR(trees)
PhylteR(trees)$WR
plot(trees)
tr <-c("tree1","tree2","tree3")
nb <- c(100)
outg <- c(0,1,5,10,20,50)
outs <- c(0,1,2,5,15)
outc <- c(0)
outc2 <- c(1,2,5,10,20,50,100,500,1000)
nrepet = 100
plan1 <- expand.grid(tr=tr, nb = nb, outg = outg, outs = outs, outc = outc)
plan2 <- expand.grid(tr=tr, nb = nb, outg = 0, outs = 0, outc = outc2)
plan=rbind(plan1,plan2)
plan = plan[rep(1:nrow(plan),each = nrepet),]
plan
?write.csv
write.csv(plan, "/home/aurore/Documents/Phylter/Tests/plan.csv")
source('~/Documents/Phylter/PhylteR.R')
source('~/Documents/Phylter/pmcoa.R')
trees = read.tree("/home/aurore/Documents/Phylter/trees/rose/TESTRAPPORT20x20-1S-1G-1C)
PH = PhylteR(trees, distance = "patristic", k=1.5, thres=0.5)
CO = pMCOA.complete(trees, distance = "patristic", k=1.5, thres=0.5)
trees = read.tree("/home/aurore/Documents/Phylter/trees/rose/TESTRAPPORT20x20-1S-1G-1C")
PH = PhylteR(trees, distance = "patristic", k=1.5, thres=0.5)
CO = pMCOA.complete(trees, distance = "patristic", k=1.5, thres=0.5)
trees
PH
trees = read.tree("/home/aurore/Documents/Phylter/trees/rose/TESTRAPPORT20x20-1S-1G-1C")
trees
PH = PhylteR(trees, distance = "patristic", k=1.5, thres=0.5)
PH = PhylteR(trees, distance = "patristic", k=1.5, thres=0.5)
class(trees)
plot(trees)
trees2matrices(trees)
source('~/Documents/Phylter/PhylteR.R')
PH = PhylteR(trees, distance = "patristic", k=1.5, thres=0.5)
CO = pMCOA.complete(trees, distance = "patristic", k=1.5, thres=0.5)
PH
CO
CO$outcompl$outgn
CO$outcompl$outsp
CO$outcompl$outcell$outcell
CO$outcell$outcell
length(CO$outcell$outcell)
nrow(CO$outcell$outcell)
length(CO$outcompl$outsp)
length(CO$outcompl$outgn=
length(CO$outcompl$outsp)
length(CO$outcell$outcell)
length(CO$outcompl$outgn)
length(CO$outcompl$outgn)
length(CO$outcompl$outsp)
length(CO$outcell$outcell)
length(PH$Complete$outgn)
length(PH$Complete$outsp)
length(PH$CellByCell$outcell)
tableau = array()
tableau[1]=COgn
tableau[2]=COgn
COgn = length(CO$outcompl$outgn)
COsp = length(CO$outcompl$outsp)
COce = length(CO$outcell$outcell)
PHgn = length(PH$Complete$outgn)
PHsp = length(PH$Complete$outsp)
PHce = length(PH$CellByCell$outcell)
tableau = array()
tableau[1]=COgn
tableau[2]=COgn
tableau
tableau[2]
trees
shiny::runApp('~/Documents/Phylter/shiny')
runApp('~/Documents/Phylter/shiny')
runApp('~/Documents/Phylter/shiny')
runApp('~/Documents/Phylter/shiny')
runApp('~/Documents/Phylter/shiny')
shiny::runApp('~/Documents/Phylter/shiny')
runApp('~/Documents/Phylter/shiny')
tr <-c("tree1","tree2","tree3")
nb <- c(100)
outg <- c(0,1,5,10,20,50)
outs <- c(0,1,2,5,15)
outc <- c(0)
outc2 <- c(1,2,5,10,20,50,100,500,1000)
nrepet = 50
plan1 <- expand.grid(tr=tr, nb = nb, outg = outg, outs = outs, outc = outc)
plan2 <- expand.grid(tr=tr, nb = nb, outg = 0, outs = 0, outc = outc2)
plan=rbind(plan1,plan2)
plan = plan[rep(1:nrow(plan),each = nrepet),]
plan
length(plan)
nrow(plan)
devtools::document()
?
?.
devtools::document()
roxygen2::roxygenise()
roxygen2::roxygenise()
?trees2matrices
?trees2matrices
?rename.genes
roxygen2::roxygenise()
?rename.genes
?rename.genes
?rename.genes
roxygen2::roxygenise()
?mat2Dist
?mat2Dist
roxygen2::roxygenise()
?mat2Dist
library(missMDA)
?imputePCA
roxygen2::roxygenise()
?imputePCA
roxygen2::roxygenise()
?imputePCA
roxygen2::roxygenise()
?impPCA.multi
roxygen2::roxygenise()
?Dist2WR
roxygen2::roxygenise()
?Dist2WR
roxygen2::roxygenise()
roxygen2::roxygenise()
library(DistatisR)
?distatis
?trees2matrices
roxygen2::roxygenise()
roxygen2::roxygenise()
roxygen2::roxygenise()
?trees2matrices
?trees2matrices
?trees2matrices
?trees2matrices
?trees2matrices
?rename.genes
roxygen2::roxygenise()
?trees2matrices
devtools::document()
?trees2matrices
devtools::document()
devtools::document()
?imputePCA
\code{\link[missMDA]{imputePCA}}
\code{\link[missMDA]{imputePCA}}
devtools::document()
devtools::document()
source('~/PhylteR/R/PhylteR.R')
devtools::document()
?ImputePCA
?ImputePCA2
?ImputePCA2
?imputePCA2
?imputePCA2
?trees2matrices
?rename.genes
?normalize
?mat2Dist
?mat2Dist
?distatis
?impPCA.multi
?Dist2WR
?Dist2WR
?Dist2WR
? plot2WR
?rm.gene.and.species
?Phylter
?PhylteR
version(PhylteR)
devtools::load_all()
#' @return return a list of distance matrices
source('~/PhylteR/R/PhylteR.R')
source("/home/aurore/Documents/Phylter/PhylteR.R")
source("/home/aurore/Documents/Phylter/Simulation.R")
setwd(dir="/home/aurore/Documents/Phylter/trees/rose/")
source("/home/aurore/Documents/Phylter/PhylteR.R")
source("/home/aurore/Documents/Phylter/Simulation.R")
setwd(dir="/home/aurore/Documents/Phylter/trees/rose/")
source('~/Documents/Phylter/PhylteR.R')
setwd(dir="/home/aurore/Documents/Phylter/trees/rose/")
source("/home/aurore/Documents/Phylter/Simulation.R")
source('~/Documents/Phylter/PhylteR.R')
source("/home/aurore/Documents/Phylter/Simulation.R")
setwd(dir="/home/aurore/Documents/Phylter/trees/rose/")
tree = rtree(5)
nbgn = 3
outgn=0
outsp =0
outcell=0
ListOut = SimOutliersHGT(tree, nbgn, outgn, outsp, outcell, sp=1)
ListOut = rename.genes(ListOut)
#genes = ListOut$genes
#ListOut = ListOut$ListTreesOut
ListOut2 = ListOut
#for (i in 1:length(genes)){
# sampSP=sample(ListOut[[genes[i]]]$tip.label, 5)
#  for (j in 1: length(sampSP)){
#   ListOut[[genes[i]]]=drop.tip(ListOut[[genes[i]]],sampSP[[j]])
# }
#}
sampGN = sample(1:length(ListOut), 1)
for (i in 1:length(sampGN)){
sampSP=sample(ListOut[[sampGN[i]]]$tip.label, 1)
for (j in 1:length(sampSP)){
ListOut[[sampGN[i]]]=drop.tip(ListOut[[sampGN[i]]],sampSP[[j]])
}
}
matricesReal= trees2matrices.Distatis(ListOut2, distance = "patristic")
matricesReal= trees2matrices(ListOut2, distance = "patristic")
matricesReal= trees2mat(ListOut2, distance = "patristic")
species = list()
grandeMatrice=matrix()
geneNames=list()
#Création d'une matrice ayant la taille maximale à remplir pour les gènes ayant des espèces manquantes
for (i in 1: length(matrices)){
species = c(species,setdiff(rownames(matrices[[i]]),species))
}
grandeMatrice=matrix(nrow=length(species), ncol= length(species))
rownames(grandeMatrice) = species
colnames(grandeMatrice) = species
#Création d'une liste contenant les noms des matrices avec des espèces manquantes
j=1
for (i in 1: length(matrices)){
if (nrow(matrices[[i]])<nrow(grandeMatrice)){
geneNames[j]=i
j=j+1
}
}
if (length(geneNames)!=0){
#Pour chaque arbre avec des espèces manquantes, remplissage de la grande matrice avec les données existantes ....
matrices2=matrices
for (i in 1: length(geneNames)){
row = rownames(matrices2[[geneNames[[i]]]])
grandeMatrice2 <- grandeMatrice
grandeMatrice2[row,row]<-matrices2[[geneNames[[i]]]][row,row]
matrices2[[geneNames[[i]]]]<-grandeMatrice2
}
}
#imputePCA
mat=impPCA.multi(matrices, scale=FALSE, center= FALSE)
matrices= trees2mat(ListOut, distance = "nodal")
species = list()
grandeMatrice=matrix()
geneNames=list()
#Création d'une matrice ayant la taille maximale à remplir pour les gènes ayant des espèces manquantes
for (i in 1: length(matrices)){
species = c(species,setdiff(rownames(matrices[[i]]),species))
}
grandeMatrice=matrix(nrow=length(species), ncol= length(species))
rownames(grandeMatrice) = species
colnames(grandeMatrice) = species
#Création d'une liste contenant les noms des matrices avec des espèces manquantes
j=1
for (i in 1: length(matrices)){
if (nrow(matrices[[i]])<nrow(grandeMatrice)){
geneNames[j]=i
j=j+1
}
}
if (length(geneNames)!=0){
#Pour chaque arbre avec des espèces manquantes, remplissage de la grande matrice avec les données existantes ....
matrices2=matrices
for (i in 1: length(geneNames)){
row = rownames(matrices2[[geneNames[[i]]]])
grandeMatrice2 <- grandeMatrice
grandeMatrice2[row,row]<-matrices2[[geneNames[[i]]]][row,row]
matrices2[[geneNames[[i]]]]<-grandeMatrice2
}
}
#imputePCA
mat=impPCA.multi(matrices, scale=FALSE, center= FALSE)
#moyenne
matricesGM = gestion.mat(matrices)
source("/home/aurore/Documents/Phylter/PhylteR.R")
source("/home/aurore/Documents/Phylter/Simulation.R")
setwd(dir="/home/aurore/Documents/Phylter/trees/rose/")
tree = rtree(10)
nbgn = 5
outgn=0
outsp =0
outcell=0
ListOut = SimOutliersHGT(tree, nbgn, outgn, outsp, outcell, sp=1)
ListOut = rename.genes(ListOut)
#genes = ListOut$genes
#ListOut = ListOut$ListTreesOut
ListOut2 = ListOut
#for (i in 1:length(genes)){
# sampSP=sample(ListOut[[genes[i]]]$tip.label, 5)
#  for (j in 1: length(sampSP)){
#   ListOut[[genes[i]]]=drop.tip(ListOut[[genes[i]]],sampSP[[j]])
# }
#}
sampGN = sample(1:length(ListOut), 3)
for (i in 1:length(sampGN)){
sampSP=sample(ListOut[[sampGN[i]]]$tip.label, 2)
for (j in 1:length(sampSP)){
ListOut[[sampGN[i]]]=drop.tip(ListOut[[sampGN[i]]],sampSP[[j]])
}
}
matricesReal= trees2mat(ListOut2, distance = "patristic")
matrices= trees2mat(ListOut, distance = "patristic")
impPCA.multi(matrices)
?impute
impPCA.multi(matrices)
impPCA.multi(matrices)
source('~/Documents/Phylter/PhylteR.R')
source('~/Documents/Phylter/PhylteR.R')
impPCA.multi(matrices)
?svd.triplet
system("pdflatex --version")
library(missMDA)
?imputePCA
?detect.cell.outliers
?IQR
?combn
?dist
?quantile
?rnorm
?cophenetic
?correction
?correction
citation("shiny")
Rd2pdf
devtools::use_testthat()
devtools::test()
source('~/Documents/Phylter/PhylteR/R/PhylteR.R')
source('~/Documents/Phylter/Simulation.R')
trees = read.tree("/home/aurore/Documents/Phylter/tree2001")
trees = read.trees("/home/aurore/Documents/Phylter/tree2001")
library(ape)
trees = read.trees("/home/aurore/Documents/Phylter/tree2001")
trees = read.tree("/home/aurore/Documents/Phylter/tree2001")
trees
ok = PhylteR(trees,distance="patristic",k=1.5,thres=0.5)
library(DistatisR)
ok = PhylteR(trees,distance="patristic",k=1.5,thres=0.5)
ok
?PhylteR
plot(trees)
trees = read.tree("/home/aurore/Documents/Phylter/tree3521")
trees = read.tree("/home/aurore/Documents/Phylter/tree3520")
plot(trees)
trees = read.tree("/home/aurore/Documents/Phylter/tree1800")
plot(trees)
ok = PhylteR(trees,distance="patristic",k=1.5,thres=0.5)
ok
tr <-c("tree1","tree2","tree3")
nb <- c(100)
outg <- c(0,1,5,10,20,50)
outs <- c(0,1,2,5,15)
outc <- c(0)
outc2 <- c(1,2,5,10,20,50,100,500,1000)
nrepet = 50
plan1 <- expand.grid(tr=tr, nb = nb, outg = outg, outs = outs, outc = outc)
plan2 <- expand.grid(tr=tr, nb = nb, outg = 0, outs = 0, outc = outc2)
plan=rbind(plan1,plan2)
plan
plan = plan[rep(1:nrow(plan),each = nrepet),]
plan
plan[100,]
plan[1000,]
plan[2000,]
trees = read.tree("/home/aurore/Documents/Phylter/tree2000")
plot(trees)
ok = PhylteR(trees,distance="patristic",k=1.5,thres=0.5)
ok
devtools::use_data()
devtools::build()
devtools::build()
source('~/Documents/Phylter/PhylteR/R/PhylteR.R')
trees2matrices <- function(trees, distance = "patristic") {
correction <- function(mat){
for (i in 1: nrow(mat)){
for (j in 1:ncol(mat)){
if (i != j) {mat[i,j] <- mat[i,j]-1}
}
}
return(mat)
}
if (distance == "nodal") {
trees <- lapply(trees,compute.brlen,1)
list.trees <- lapply(trees, cophenetic)
list.trees <- lapply(list.trees,correction)
}
else if (distance == "patristic") {
list.trees <- lapply(trees, cophenetic)
}
if (!is.null(names(trees))) {
names(list.trees) <- names(trees)
}
return(list.trees)
}
trees = read.tree("/home/aurore/downloadData")
trees = read.trees("/home/aurore/downloadData")
source('~/Documents/Phylter/PhylteR/R/PhylteR.R')
trees = read.tree("/home/aurore/downloadData")
source('~/Documents/Phylter/pmcoa.R')
trees = read.tree("/home/aurore/downloadData")
trees
trees2matrices
source('~/Documents/Phylter/PhylteR/R/PhylteR.R')
trees2matrices()
trees2matrices
trees2matrices(trees)
trees[[1]]$Nnode
install.packages("beepr")
?beepr
beepr
beepr::beep()
beepr::beep
beepr::beep()
beepr::beep()
?beep
beepr::beep(sound = 8)
beepr::beep(sound = 9)
beepr::beep(sound = 11)
beepr::beep(sound = 10)
beepr::beep(sound = 7)
beepr::beep(sound = 6)
beepr::beep(sound = 5)
beepr::beep(sound = 4)
beepr::beep(sound = 3)
beepr::beep(sound = 2)
beepr::beep(sound = 1)
beepr::beep(sound = 8)
install.packages("beepr")
Sys.sleep(5); beepr::beep(8)
install.packages("beepr")
Sys.sleep(5); beepr::beep(8)
Sys.sleep(5); beepr::beep(4)
Sys.sleep(5); beepr::beep(4)
beepr::beep(3)
beepr::beep(3)
beepr::beep(4)
beepr::beep(5)
PhylteR(trees)
trees
class(trees)
plot(trees)
bvalue
source('~/Documents/Phylter/pmcoa.R')
plot(trees)
PhylteR(trees)
trees
?PhylteR
PhyleR(trees, "patristic")
PhylteR(trees, "patristic")
names(trees)
is.null(names(trees))
c(1:length(trees))
as.character(c(1:length(trees)))
install.packages(c("crul", "DBI", "devtools", "dplyr", "FactoMineR", "gdata", "jsonlite", "R6", "rentrez", "segmented", "shinydashboard", "tibble", "XML"))
