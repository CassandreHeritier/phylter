{
    "collab_server" : "",
    "contents" : "# trees2matrices changes a list of trees into a list of matrices\n\ntrees2matrices <- function(trees, distance = \"patristic\") {\n  if (distance == \"nodal\") {\n    trees <- lapply(trees,compute.brlen,1)\n    list.trees <- lapply(trees, cophenetic)\n    list.trees <- lapply(list.trees,correction)\n  }\n  else if (distance == \"patristic\") {\n    list.trees <- lapply(trees, cophenetic)\n  }\n  if (!is.null(names(trees))) {\n    names(list.trees) <- names(trees)\n  }\n  return(list.trees)\n}\n\n# this function permits the user to add gene names (as list) to the trees. If no names is given, genes are numeroted from 1 to the number of genes.\n\nrename.genes <- function(trees, gene.names = NULL) {\n  if(!is.null(gene.names)) {\n    names(trees) <- gene.names\n  } else {\n    if(is.null(names(trees))) {\n      names(trees) <- as.character(c(1:length(trees)))\n    }\n  }\n  return(trees)\n}\n\n# mat2Dist applies distatis on a list of distance matrices\n\nmat2Dist <- function(matrices, Norm = \"NONE\") {\n  # transform the list of matrices to a cube\n  row <- rownames(matrices[[1]])\n  for (i in 1:length(matrices)) {\n    matrices[[i]] <- matrices[[i]][row, row]\n  }\n  genesNumber <- length(matrices)\n  speciesNumber <- nrow(matrices[[genesNumber]])\n  TheVeryBigCube <- array(0, c(speciesNumber, speciesNumber, genesNumber))\n  for (i in 1:genesNumber) {\n    TheVeryBigCube[, , i] <- matrices[[i]]\n  }\n  rownames(TheVeryBigCube) <- rownames(matrices[[1]])\n  colnames(TheVeryBigCube) <- colnames(matrices[[1]])\n  # Apply distatis on the cube and keep genes names in distatis results\n  Distatis <- distatis(TheVeryBigCube, Norm = Norm)\n  dimnames(Distatis$res4Splus$PartialF)[[3]] <- names(matrices)\n  return(Distatis)\n}\n\n# Imputing missing data in matrices with missMDA package\n\nimpPCA.multi <- function(matrices, ncp = 3, center = FALSE, scale = FALSE, maxiter = 10000) {\n  geneNames <- list()\n  # Create a matrix with every species to fill : GrandeMatrice\n  species<-unique(unlist(lapply(matrices, rownames)))\n  nbsp<-length(species) #ca Ã©vite de le recalculer plein de fois.\n  grandeMatrice=matrix(nrow = length(species), ncol = nbsp)\n  rownames(grandeMatrice) = species\n  colnames(grandeMatrice) = species\n  # Create a list of matrices names with missing data\n  dimMat<-unlist(lapply(matrices, nrow))\n  geneNames<-names(which(dimMat<nbsp))\n  matrices2 = matrices\n  if (length(geneNames) != 0) {\n    # For each matrix with missing data, we fill the GrandeMatrice\n    for (i in 1:length(geneNames)) {\n      row <- rownames(matrices2[[geneNames[[i]]]])\n      grandeMatrice2 <- grandeMatrice\n      grandeMatrice2[row, row] <- matrices2[[geneNames[[i]]]][row,row]\n      matrices2[[geneNames[[i]]]] <- grandeMatrice2\n    }\n    matrices3 <- matrices2\n    row <- rownames(matrices2[[1]])\n    for (i in 1:length(matrices2)) {\n      matrices3[[i]] <- as.vector(matrices2[[i]][row, row][upper.tri(matrices2[[i]][row, row])])\n    }\n    mat <- do.call(cbind,matrices3)\n    # estimating missing data\n    matIPCA <- imputePCA(mat, center = center, scale = scale, maxiter = maxiter)\n    matIPCA <- matIPCA$completeObs\n    matricesFT <- list()\n    for (i in 1:length(matrices2)) {\n      matrices[[i]] <- matrix(nrow = length(row), ncol = length(row))\n      rownames(matrices[[i]]) <- row\n      colnames(matrices[[i]]) <- row\n      data=as.vector(matIPCA[, i])\n      matrices[[i]][upper.tri(matrices2[[i]])] <- data\n      matricesFT[[i]] <- t(matrices[[i]])\n      matrices[[i]][lower.tri(matrices2[[i]])] <- matricesFT[[i]][lower.tri(matrices2[[i]])]\n      for (j in 1:ncol(matrices[[i]])) {\n        matrices[[i]][j, j] <- 0\n      }\n    }\n  }\n  return(matrices)\n}\n\n# imputePCA2 function from missMDA package but with the possibility to not center the data. And with no negative values possibly imputed.\n\nimputePCA2 <- function (X, ncp = 2, center = FALSE, scale = FALSE, method = c(\"Regularized\", \"EM\"), row.w = NULL, coeff.ridge = 1, threshold = 1e-6, seed = NULL,nb.init = 1, maxiter = 1000, ...) {\n  impute <- function (X, ncp = 4, center = FALSE, scale = FALSE, method = NULL, threshold = 1e-6,seed = NULL, init = 1, maxiter = 1000, row.w = NULL, coeff.ridge = 1, ...) {\n    moy.p <- function(V, poids) {\n      res <- sum(V * poids, na.rm = TRUE) / sum(poids[!is.na(V)])\n    }\n    ec <- function(V, poids) {\n      res <- sqrt(sum(V ^ 2 * poids,na.rm = TRUE) / sum(poids[!is.na(V)]))\n    }\n    nb.iter <- 1\n    old <- Inf\n    objective <- 0\n    if (!is.null(seed)) {\n      set.seed(seed)\n      }\n    X <- as.matrix(X)\n    ncp <- min(ncp, ncol(X), nrow(X) - 1)\n    missing <- which(is.na(X))\n    mean.p <- apply(X, 2, moy.p, row.w)\n    if (center != TRUE){\n      mean.p <- rep(0, ncol(X))\n    }\n    Xhat <- t(t(X) - mean.p)\n    et <- apply(Xhat, 2, ec, row.w)\n    if (scale) Xhat <- t(t(Xhat) / et)\n    if (any(is.na(X))) Xhat[missing] <- 0\n    if (init > 1) Xhat[missing] <- rnorm(length(missing)) # random initialization\n    fittedX <- Xhat\n    if (ncp == 0) nb.iter = 0\n    while (nb.iter > 0) {\n      Xhat[missing] <- fittedX[missing]\n      if (scale) Xhat = t(t(Xhat) * et)\n      Xhat <- t(t(Xhat) + mean.p)\n      if (center == TRUE){\n        mean.p <- apply(Xhat, 2, moy.p, row.w)\n      }\n      Xhat <- t(t(Xhat) - mean.p)\n      et <- apply(Xhat, 2, ec, row.w)\n      if (scale) Xhat <- t(t(Xhat) / et)\n      svd.res <- svd.triplet(Xhat, row.w = row.w, ncp = ncp)\n      sigma2  <- nrow(X) * ncol(X) / min(ncol(X), nrow(X)-1) * sum((svd.res$vs[-c(1:ncp)] ^ 2) / ((nrow(X) - 1) * ncol(X) - (nrow(X) - 1) * ncp - ncol(X) * ncp + ncp ^ 2))\n      sigma2 <- min(sigma2 * coeff.ridge, svd.res$vs[ncp + 1] ^ 2)\n      if (method == \"em\") sigma2 <-0\n      lambda.shrinked = (svd.res$vs[1:ncp] ^ 2 - sigma2) / svd.res$vs[1:ncp]\n      fittedX = tcrossprod(t(t(svd.res$U[, 1:ncp, drop = FALSE] * row.w) * lambda.shrinked), svd.res$V[, 1:ncp, drop = FALSE])\n      fittedX <- fittedX / row.w\n      # No negative value\n      fittedX[fittedX < 0] = 0\n      diff <- Xhat-fittedX\n      diff[missing] <- 0\n      objective <- sum(diff ^ 2 * row.w)\n      criterion <- abs(1 - objective / old)\n      old <- objective\n      nb.iter <- nb.iter + 1\n      if (!is.nan(criterion)) {\n        if ((criterion < threshold) && (nb.iter > 5)) nb.iter <- 0\n        if ((objective < threshold) && (nb.iter > 5)) nb.iter <- 0\n      }\n      if (nb.iter > maxiter) {\n        nb.iter <- 0\n        warning(paste(\"Stopped after \", maxiter, \" iterations\"))\n      }\n    }\n    if (scale) Xhat <- t(t(Xhat) * et)\n    Xhat <- t(t(Xhat) + mean.p)\n    completeObs <- X\n    completeObs[missing] <- Xhat[missing]\n    if (scale) fittedX <- t(t(fittedX) * et)\n    fittedX <- t(t(fittedX) + mean.p)\n\n    result <- list()\n    result$completeObs <- completeObs\n    result$fittedX <- fittedX\n    return(result)\n  }\n  # Main program\n  method <- match.arg(method, c(\"Regularized\", \"regularized\", \"EM\", \"em\"), several.ok = T)[1]\n  obj = Inf\n  method <- tolower(method)\n  if (ncp > min(nrow(X) - 2, ncol(X) - 1)) stop(\"ncp is too large\")\n  if (is.null(row.w)) row.w = rep(1, nrow(X)) / nrow(X)\n  for (i in 1:nb.init){\n    if (!any(is.na(X))) return(X)\n    res.impute = impute(X, ncp = ncp, scale = scale,center = center, method = method, threshold = threshold, seed = if(!is.null(seed)){(seed * (i - 1))}else{NULL}, init = i, maxiter = maxiter, row.w = row.w, coeff.ridge = coeff.ridge)\n    if (mean((res.impute$fittedX[!is.na(X)] - X[!is.na(X)]) ^ 2) < obj) {\n      res <- res.impute\n      obj <- mean((res.impute$fittedX[!is.na(X)] - X[!is.na(X)]) ^ 2)\n    }\n  }\n  return(res)\n}\n\n# create 2WR matrix from distatis results\n\nDist2WR <- function(Distatis) {\n  matrixWR2 <- matrix(nrow = dim(Distatis$res4Splus$PartialF)[[1]], ncol = dim(Distatis$res4Splus$PartialF)[[3]])\n  colnames(matrixWR2) <- dimnames(Distatis$res4Splus$PartialF)[[3]]\n  rownames(matrixWR2) <- dimnames(Distatis$res4Splus$PartialF)[[1]]\n\n  for (i in 1:length(dimnames(Distatis$res4Splus$PartialF)[[3]])){\n    for (j in 1:length(dimnames(Distatis$res4Splus$PartialF)[[1]])){\n      x <- (Distatis$res4Splus$PartialF[dimnames(Distatis$res4Splus$PartialF)[[1]][j], , dimnames(Distatis$res4Splus$PartialF)[[3]][i]] - Distatis$res4Splus$F[dimnames(Distatis$res4Splus$PartialF)[[1]][j], ]) ^ 2\n      matrixWR2[dimnames(Distatis$res4Splus$PartialF)[[1]][j], dimnames(Distatis$res4Splus$PartialF)[[3]][i]] <- sqrt(sum(x))\n    }\n  }\n  return(matrixWR2)\n}\n\n# Fonction to plot 2WR matrix\n\n plot2WR <- function(matrixWR2) {\n  WR <- normalize(matrixWR2)\n  names <- list()\n  names[[1]] <- \"gene\"\n  names[[2]] <- \"specie\"\n  names[[3]] <- \"value\"\n  MAT <- matrix(nrow = length(WR), ncol = 3)\n  colnames(MAT) <- names\n  k <- 1\n  for (i in 1:nrow(WR)) {\n    for (j in 1:ncol(WR)) {\n      MAT[k, 2] <- rownames(WR)[i]\n      MAT[k, 1] <- colnames(WR)[j]\n      MAT[k, 3] <- WR[i, j]\n      k <- k + 1\n    }\n  }\n  MAT <- as.data.frame(MAT)\n  genes <- as.character(MAT$gene)\n  species <- as.character(MAT$specie)\n  distanceToRef <- as.numeric(as.character(MAT$value))\n\n  pl <- ggplot(MAT, aes(genes, species, z = distanceToRef))\n  pl <- pl + geom_tile(aes(fill = distanceToRef)) + theme_bw() + scale_fill_gradient(low = \"white\", high = \"blue\")\n  pl <- pl + theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 13, color = \"black\"))\n  pl <- pl + theme(axis.text.y = element_text(angle = 00, hjust = 1, size = 13, color = \"black\"))\n  pl <- pl + theme(axis.title.y = element_text(size = rel(1.8), angle = 90))\n  pl <- pl + theme(axis.title.x = element_text(size = rel(1.8), angle = 00))\n  # pl + coord_fixed(ratio=1/5)\n  return(pl)\n}\n\n# Suppress complete outiers (species or genes) in trees in order to detect cell outliers in a second time.\n# Fonction from phylo_MCOA slitly modified to fit our method.\n\nrm.gene.and.species <- function(trees, sp2rm, gn2rm) {\n  gene.names <- list()\n  for (i in 1:length(labels(trees))) {\n    gene.names[i] <- labels(trees)[i]\n  }\n  if (length(sp2rm) > 0) {\n    for (i in 1:length(trees)) {\n      sp <- trees[[i]]$tip.label\n      toremove <- intersect(sp, sp2rm)\n      trees[[i]] <- drop.tip(trees[[i]], toremove)\n    }\n  }\n  if (length(gn2rm) > 0) {\n    genes2keep <- setdiff(gene.names, gn2rm)\n    trees2 <- list()\n    j <- 0\n    for (i in 1:length(trees)) {\n      if (is.element(gene.names[i], genes2keep)) {\n        j <- j + 1\n        trees2[[j]] <- trees[[i]]\n      }\n    }\n    names(trees2) <- genes2keep\n  } else {\n    trees2 <- trees\n  }\n  return(trees2)\n}\n\n# Phylter Function to detect complete and cell outliers from a list of trees\n\nPhylteR <- function(trees, distance = \"patristic\", k = 1.5, thres = 0.5, gene.names = NULL, Norm = \"NONE\") {\n  trees <- rename.genes(trees, gene.names = gene.names)\n  RES <- NULL\n  matrices <- trees2matrices(trees, distance=distance)\n  matrices <- impPCA.multi(matrices)\n  Dist <- mat2Dist(matrices, Norm = Norm)\n  WR <- Dist2WR(Dist)\n  CompOutl <- detect.complete.outliers(WR, k = k, thres = thres)\n  if (length(CompOutl$outsp) > 0 || length(CompOutl$outgn) > 0) {\n    TREESwithoutCompleteOutlierDist <- rm.gene.and.species(trees, CompOutl$outsp, CompOutl$outgn)\n    matrices2 <- trees2matrices(TREESwithoutCompleteOutlierDist, distance = distance)\n    matrices2 <- impPCA.multi(matrices2)\n    Dist2 <- mat2Dist(matrices2, Norm = Norm)\n    WR2 <- Dist2WR(Dist2)\n    CellOutl2 <- detect.cell.outliers(WR2, k = k + 2)\n    RES$Complete <- CompOutl\n    RES$CellByCell <- CellOutl2\n  } else {\n    CellOutl2 <- detect.cell.outliers(WR,  k = k + 2)\n    RES$Complete <- CompOutl\n    RES$CellByCell <- CellOutl2\n  }\n  return(RES)\n}\n\n#This function normalizes the 2WR matrix (or any matrix) according to the species (rows) or to the genes (columns).\n\nnormalize <- function(mat, what = \"none\") {\n  if (what == \"species\") mat <- apply(mat, 2, function(x) {x / mean(x)})\n  else if (what == \"genes\") mat <- t(apply(mat, 1, function(x) {x / mean(x)}))\n  else if (what == \"none\") {\n    mat <- mat\n    #cat(\"The matric is unchanged.\\n\")\n  } else print (\"WARNING! Error in the kind of scaling you want! No scaling applied.\")\n  return(mat)\n}\n\n# Detection of complete outliers from phylo-mcoa\ndetect.complete.outliers <- function(mat2WR, k = 1.5, thres = 0.5) {\n  outl.sub <- function(x, k) {\n    return(x > quantile(x)[4] + k * IQR(x) + 1e-10)\n    ##note: the 1e-10 ,is because when all values are similar except one, the first one is considered as equal to the third quartile... May be a bug in quantile function?\n  }\n  tabgn <- normalize(mat2WR, \"genes\")\n  tabgn.TF <- t(apply(tabgn, 1, outl.sub, k = k))\n  tabsp <- normalize(mat2WR, \"species\")\n  tabsp.TF <- apply(tabsp,2, outl.sub, k = k)\n  tabgn.TF[tabgn.TF == FALSE] <- 0\n  tabgn.TF[tabgn.TF == TRUE] <- 1\n  tabsp.TF[tabsp.TF == FALSE] <- 0\n  tabsp.TF[tabsp.TF == TRUE] <- 1\n  score.genes <- apply(tabgn.TF, 2, function(x) {sum(x) / length(x)})\n  score.species <- apply(tabsp.TF, 1, function(x) {sum(x) / length(x)})\n  out.genes <- names(score.genes)[score.genes > thres]\n  out.species <- names(score.species)[score.species > thres]\n  RES <- NULL\n  RES$mat2WR <- mat2WR\n  #RES$thres <- thres\n  #RES$allgn <- names(score.genes)\n  #RES$allsp <- names(score.species)\n  #RES$scoregn <- score.genes\n  #RES$scoresp <- score.species\n  #RES$TFgn <- score.genes>thres\n  #RES$TFsp <- score.species>thres\n  RES$outgn <- out.genes\n  RES$outsp <- out.species\n  return(RES)\n}\n\n# Function to detect cell outliers (species and genes)\ndetect.cell.outliers <- function(mat2WR, k = 3) {\n  ans <- \"y\"\n  if (ans == \"y\") {\n    MAT <- mat2WR\n    detect.island <- function(arr) {\n      spi.names <- names(arr)\n      spi <- 1:length(spi.names)\n      names(spi) <- spi.names\n      true.names <- names(arr)[arr == TRUE]\n      if (length(true.names) == 1) {\n        return(list(true.names))\n      }\n      else if (length(true.names) > 1) {\n        true.i <- spi[true.names]\n        res<-dist(true.i)\n        table.i <- cbind(t(combn(attributes(res)$Labels, 2)), array(res))\n        in.island<-NULL\n        if (length(table.i[table.i[, 3] == \"1\", 3]) == 0) {\n          in.island <- \"nopair\"\n          list.i <- NULL\n        }\n        if (length(table.i[table.i[,3] == \"1\", 3]) == 1) {\n          in.island <- table.i[table.i[,3] == \"1\", c(1, 2)]\n          list.i <- list(in.island)\n        }\n        if (is.null(in.island)) {\n          table.small <- table.i[table.i[,3] == \"1\",c(1,2)]\n          list.i <- list()\n          for (i in 1:nrow(table.small)) list.i[[i]] <- table.small[i, ]\n          for (i in 1:(length(list.i) - 1)) {\n            for (j in (i+1):length(list.i)) {\n              if (length(intersect(list.i[[i]], list.i[[j]])) > 0) {\n                list.i[[i]] <- c(list.i[[i]], list.i[[j]])\n                list.i[[j]] <- \"out\"\n                list.i[[i]] <- unique(list.i[[i]])\n              }\n            }\n          }\n          list.i2 <- list()\n          w <- 0\n          for (i in 1:length(list.i)) {\n            if ((length(list.i[[i]]) > 1)&&(list.i[[i]][1] != \"out\")) {\n              w <- w+1\n              list.i2[[w]] <- list.i[[i]]\n              in.island <- c(in.island, list.i[[i]])\n            }\n          }\n          list.i <- list.i2\n        }\n        out.island <- as.list(setdiff(true.names, in.island))\n        return(c(list.i, out.island))\n      }\n    }\n    outl.sub <- function(x, k) {\n      return(x > quantile(x)[4] + k * IQR(x) + 1e-10)\n    }\n    MATspgn <- normalize(mat2WR, \"genes\") * normalize(mat2WR, \"species\")\n    testspgn1 <- apply(MATspgn, 2, outl.sub, k = k)\n    testspgn2 <- t(apply(MATspgn, 1, outl.sub, k = k))\n    testspgn <- testspgn1 * testspgn2\n    testFALSE <- testspgn\n    testFALSE[testFALSE == FALSE] <- 0\n    testFALSE[testFALSE == TRUE] <- 1\n    if (sum(testFALSE) > 0) {\n      out.list <- apply(testspgn, 2, detect.island)\n      genes <- colnames(testspgn)\n      res <- c(NA,NA)\n      for (i in 1:length(out.list)) {\n        if (!is.null(out.list[[i]])) {\n          for (j in 1:length(out.list[[i]])) {\n            if (length(out.list[[i]][[j]]) == 1) res <- rbind(res, c(out.list[[i]][[j]], genes[i]))\n            if (length(out.list[[i]][[j]]) > 1) {\n              vals <- MATspgn[out.list[[i]][[j]], genes[i]]\n              res <- rbind(res, c(names(vals)[vals == max(vals)], genes[i]))\n            }\n          }\n        }\n      }\n      colnames(res) <- c(\"Species\", \"Genes\")\n      ##we construct the MATfinal\n      MATfinal <- testspgn\n      MATfinal[,] <- 0\n      for (w in 2:nrow(res)) MATfinal[res[w, 1], res[w, 2]] <- 1\n        RESULT <- NULL\n        #RESULT$mat2WR <- mat2WR\n        #RESULT$matspgn <- MATspgn\n        #RESULT$matfinal <- MATfinal\n        #RESULT$testFALSE <- testFALSE\n        RESULT$outcell <- res[2:nrow(res), ]\n      return(RESULT)\n    } else return(NULL)\n  } else cat(\"\\n---Operation canceled by the user.---\\n\")\n}\n",
    "created" : 1495114874831.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2250671376",
    "id" : "F84F1D16",
    "lastKnownWriteTime" : 1495197647,
    "last_content_update" : 1495197647814,
    "path" : "~/Documents/Phylter/PhylteR/R/PhylteR.R",
    "project_path" : "R/PhylteR.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}